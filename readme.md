

# git common commands:

git clone "url" 

git init

git add .

git commit -m "message abc..."

git push -u origin branch_name (for first time, later just: git push)

git pull --set-upstream origin branch_name (for first tme, later just: git pull)

git log

git checkout -b copied_branch

git help command_name

git remote add origin "https://..."

git remote -v

git config --global pull.ff

git pull --rebase origin main

git checkout main

git merge feature_branch

git diff HEAD..branch

git show HEAD..branch


# github basics:

- create account on Github.
After created, the email will be hidden and github automatically generate an alternative email (id-username@noreply....).
This email will be used when committing to repository. (in Settings > Emails)

- create a repository.
after creating repository, repository has a https url for later cloning from git client.

- download & install Git. then set environemnt variable to point to Git's bin directory.

- config git:  

git config --global user.name "your_user_name"

git config --global user.email "alternative_email_from_github"

Think of 'user.name' and 'user.email' as your signature. 
You can set 'user.name' to anything. 
remember to set 'user.email' to the alternative email generated by Github. 
When you push commit to Github, Github will look at your email (the alternative email) and resolve to your Github account.


- Git login:
first, go to Github > Settings > Developer settings > Personal access tokens. generate token.
Think of this token as the key to login to Github from Git. 
(this token has nothing to with your user.name & email set above)

When performing actions that needs identity (eg: git push), 
git will open Credential Dialog and ask you to enter your credentials.
Enter the token generated above.
Also, select the 'use for later' option or something like that.

If later, you want to use another identity, 
for Windows, go to Control panel > User accounts > credential manager > windows credentials > generic credentials > remove entry with: git:https://github.com
Then do some identity-related tasks on git, it will open dialog to ask credentials again.
remember to set user.email to your new alternative email.

# commit & branch & changes/differences:

Each **commit** is assigned a hash value which is unique within the repository.

**branch** or **tag** is just a label pointing to a commit.
branch can point to any commit, while tag is fixed at specified commit.

For example, if branchA has 3 commits and then branchB is created based on branchA.  
That would like below:  
1->2->3 (branchA, branchB)  

instead of:   
1->2->3 (branchA)  
1->2->3 (branchB) (wrong. never two commits with same hash value represennted in a repo)  

then, if branchA commits and branchB commits, graph will be:  
1->2->3->4 (branchA)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\   

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5 (branchB)  

I recommend using: `gitk` or sublime merge (a git client) to view graph of commit history.

### Changes after merging
To view changes after merging, there's only way that is accurate is trying merging.  
eg: 'main' is about to merge 'branch' (HEAD is pointing to 'main')  

For simple cases where the 'branch' does not involve rebase,   
use: `git show HEAD..branch`  

For more accurate, create a temporary branch to try merging then compare differences.  
create a temporary branch 'temp' based on 'main'.   
then just merge 'temp' to 'branch'. after merging, 'temp' will point to the merge commit.  
to see differences: ``git diff main..temp ``  
(same strategy for view difference after rebasing)  

--> in case forget to create 'temp' branch, use reflog:  
``git reflog ``   
(find the last checkout to 'main' branch)

``git reset --hard last_checkout_commit  ``  
(reset to last checkout commit in case the merge or rebase is not as expected)


### git diff, git log, git show
``git diff HEAD branch``  
(show what're in 'branch' but not in 'HEAD'.  
if HEAD is inherited from 'branch', then HEAD changes some files previously in 'branch', this command will show those differences in 'branch' too.  
Those differences are not accounted when merging.  
So this is not appropriate for previewing what changed after merging.
)

``git diff HEAD..branch``  
(same as above: diff HEAD branch)  

``git diff HEAD...branch``  
(find the common ancestor of HEAD and branch, then compare it with the 'branch' (tip of 'branch')  
if HEAD is inherited from 'branch' then 'branch' makes some changes. those changes will be shown by this command.  
But consider the case 'branch' rebases to another branch, then the common ancestor will not the same as before.  
then if use this command, the changes shown will include the common changes between HEAD and 'branch'. illustrated as below:  
main: 1->2->3->4  
test: 1->2->3  
br2: 1->2->3->4  
Now the common ancestor betwen main & br2 is 4.  

then test changes: 1->2->3-> A  
and 'main' rebases to branch 'test'.  
main becomes: 1->2->3-> A ->4  

now, if use command: ``git diff br2...main``  
the common ancestor is 3, not 4 like before. so the changes are: A->4  
4 are the common change, it is already in 'br2', but still be shown.  
This makes this command also not appropriate for previewing what changes   after merging.

)

``git log HEAD..branch``  
(show commits in 'branch' but not in 'HEAD')  

``git log HEAD...branch``  
(show every commits in 'branch' or 'HEAD' from the common ancestor)  

``git show HEAD..branch``  
(same as git log, but show commits along with changes)  


# Github control & manage branch:  

to avoid directly pushing to 'main' branch,
to make all changes to 'main' branch must go through Pull Request.
to restrict who can approve or allow merging to 'main' branch.

see my own answer: https://stackoverflow.com/a/72351761/16550663

see sample repo: https://github.com/qttq23/hell-world.git

in a nutshell:
- create a github-action to validate the actor who clicks 'run'/'re-run'. if that actor is a powerful collaborator, the github-action passes.
(use the 'pull_request_target' event instead of 'pull_request' event to make actions run from the 'base' context instead of 'merging' context)
- go to settings, set rule for main branch. select 'pass check before mergeing' and 'required up to date'. search the jobs specified in github-action. 
(if jobs not shown, try run the action manually some times then try again.)

(if already use 'pull_request_target', old way below are not needed.
- to prevent others from editing github-action file, create CODEOWNERS file.
- go to settings, set rule for main branch: set 'require pull request before merging', and all its sub-options.
)


# Github merge, rebase, fast-forward:
**recommended**:
- set default: git config --global pull.ff only (this makes pull aborted if upstream branch & local branch diverge).
- if divergence, try: git pull --rebase (this makes everything you made appears after the upstream's changes. 
so you can easily look at what you did)
- if you want your branch to be up-to-date with the certain branch, use merge. don't rebase. only rebase (in standard mode, not interactive) when pulling. 
(
because git/github recommends merging instead of rebasing. rebasing can make it hard to know exactly what you done, and potentially miss commits.
if rebase conflict, you resolve conflicted file and continue rebase workflows (git rebase --continue) which a bit complicated and easy to fail in some steps.
while in merge, git shows you what files are conflicted, you resolve then commit. that's it.
)

**fast-forward**: can only happen when the receiving branch is behind the merging branch. git pull always try using fast-forward before other methods.  
eg: if branchA fast-forward merges branch B.  
branchB: 1->2->3->4  
branchA: 1->2  
after fast-forward: branchA: 1->2->3->4 (the head of A is fast-forwarded to 4)  
command-line:   
 git checkout branchA  
 git pull --ff-only . branchB  

**rebase**: put changes of receiving branch after the base branch. no merge commit is created. usually used when pulling another remote branch.  
eg: if branch A rebases to branch B:  
branchB: 1->2->3->4  
branchA: 1->2->5->6  
after rebase: branchA: 1->2->3->4 ->5->6 (the changes of A is put after the tip of branch B)  
command-line:   
 git checkout branchA  
 git pull --rebase origin branchB  

**rebase interactive**: usually used when re-writing commit history for its own branch. for example, combine some unneccessary commits into one.
It's dangerous due to potential commit removing permanently (if you accidentally hit the command 'drop' in rebase editor).
Use it carefully if you have really long list of commits for a single feature.
(note that if you squash to some old shared commits, when you create pull request, you will see old changes along with new changes. 
only after you merge that pull request, the merge commit is generated and that merge commit will contain new changes. 
It's safe, but make you hard to know which changes is old or new)  
command-line:  
 get checkout branchA  
 git rebase --interactive commit_sha...  
 in rebase editor:  
  i: to insert.  
  esc: to go out of insert mode.  
  :wq -> write then quit.  
  :exit -> abort.  

**merge**: (or three-ways merge), will mix changes from receiving branch to passed branch in timestamp order. create a separate commit indicates merging.  
eg: if branchA merges branch B.  
branchB: 1->2->4->6  
branchA: 1->2->3->5  
after merging: branchA: 1->2->3->4->5->6->new merge commit  
command-line:   
 git checkout branchA  
 git merge branchB  

example:  

nobase:  
 remote: 1->2  
 local: 3->4  
-> rebase: ok. merge & fast-forward: failed.  

1base:  
 remote: 1-> 2->3  
 local:  1-> 5->6  
-> merge, rebase: ok. fast-forward: failed.  

uptodate:  
 remote: 1->2  
 local: 1->2->3->4  
-> all are ok.  

outdated:  
 remote: 1->2->3->4  
 local: 1->2  
-> all are ok. because git pull always try and use fast-forward first.  

 
# Github fork:
In github repository, only collaborators are allowed to push/write to a new branch.  
Contributor (who're not a collaborator) can't create or update branch, they can only create pull request.  
Fork solves this. Contributors forks a repository to make their own repository.  
They can do anything with their own forked repository such as create and push to branch.  
When they need to contribute to original branch, they create they pull request from forked repo to original repo.  

issue: about github-actions  
 forkA/branch1 -> forkA/branch2 (github actions will run in pull request)  
 forkA/branch1 -> originRepo/branch1 (github actions may not running in pull request event ?? only run on 'pull_request_target' ??)  

practise:  
-create original repo  
(setup pull request restriction, see sample repo: https://github.com/qttq23/hell-world.git)  

-fork a repo on github web  
https://docs.github.com/en/get-started/quickstart/fork-a-repo#forking-a-repository  

-clone to local.  
https://docs.github.com/en/get-started/quickstart/fork-a-repo#cloning-your-forked-repository  
 
-set up local upstream  
https://docs.github.com/en/get-started/quickstart/fork-a-repo#configuring-git-to-sync-your-fork-with-the-original-repository  

-changes in local. push to web. (ok. the main branch on forked repo is not protected)  

-the original repo changed.  

-create pull request to original.  
https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork  

-pull changes and recommit to pull request.  
from local git:  
https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/syncing-a-fork#syncing-a-fork-from-the-command-line  
The local git pulls directly from original repo.  

from web ui:  
https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/syncing-a-fork#syncing-a-fork-from-the-web-ui  
if fetch & merge to web-ui, the local git has to pull from web-ui (the forked repo).  


-orginal repo commit additional changes.  
if pull request creator allows commits from original repo, then the original repo's collaborators (who have write access) will be able to make changes in the forked repo.  
In other word, original repo's collaborators can create branch or commit to any branch in forked repo.  
Therefore, they can update the changes directly to pull-request merging branch.  
https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/committing-changes-to-a-pull-request-branch-created-from-a-fork  

-original repo approves and merges changes from fork repo.  

 

# Git submodule
??
